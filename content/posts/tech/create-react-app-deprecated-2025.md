---
title: "Create React App의 몰락: '쉬운 시작'이라는 거짓말의 종말"
date: "2025-04-28"
category: "tech"
tags: ["React", "CRA", "CreateReactApp", "BuildTools", "DeveloperExperience"]
excerpt: "React 공식 스타터가 사라진다. 5년간 CRA를 사용해온 개발자가 말하는 진짜 이유와 대안들. 편리함 뒤에 숨겨진 기술 부채와 생태계의 변화를 낱낱이 분석한다."
author: "KISO"
image: "https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?w=800&h=400&fit=crop"
---

# Create React App의 몰락: '쉬운 시작'이라는 거짓말의 종말

"React 프로젝트 만들기? `npx create-react-app` 하면 끝이죠!"

5년 전만 해도 이는 당연한 이야기였다. React 공식 팀이 만든 스타터 킷이니까 안전하고, 설정도 간단하고, 초보자도 쉽게 사용할 수 있다고 생각했다.

하지만 2023년 React 공식 문서에서 Create React App(CRA) 추천을 중단했고, 이제는 사실상 deprecated 상태가 되었다. 많은 개발자들이 "갑자기 왜?"라며 당황하고 있지만, 실제로는 예견된 일이었다.

5년간 수십 개의 CRA 프로젝트를 운영해본 결과, 한 가지 확실한 사실을 깨달았다. **CRA는 처음부터 문제투성이였고, 단지 대안이 없어서 참았을 뿐이다.**

## CRA의 달콤한 약속과 쓰라린 현실

### "Zero Configuration"의 거짓말

CRA의 가장 큰 마케팅 포인트는 "Zero Configuration"이었다. 복잡한 Webpack 설정 없이도 바로 React 개발을 시작할 수 있다는 것이다.

```bash
npx create-react-app my-app
cd my-app
npm start
```

정말 간단해 보인다. 하지만 이 "Zero Configuration"은 사실 "Hidden Configuration"이었다. 설정이 없는 게 아니라 숨겨져 있을 뿐이다.

**실제 프로젝트에서 마주치는 현실:**
- "이 라이브러리가 왜 안 되죠?" → Webpack 설정 문제
- "IE 11 지원해야 해요" → Polyfill 설정 복잡함
- "번들 크기를 줄여주세요" → 최적화 옵션 제한적
- "환경변수 추가하고 싶어요" → REACT_APP_ 접두사 강제

결국 조금만 복잡해져도 `npm run eject`를 해야 했다. 그 순간 "Zero Configuration"은 완전히 사라지고 수백 개의 설정 파일이 쏟아져 나온다.

### 종속성 지옥의 시작

CRA는 무수히 많은 패키지에 의존한다. 새 프로젝트를 만들면 `node_modules`에 몇백 개의 패키지가 설치된다.

```json
// package.json의 일부 (실제로는 더 많음)
{
  "dependencies": {
    "react-scripts": "5.0.1"
  }
}
```

하지만 `react-scripts` 하나가 끌고 오는 의존성들을 보면:

```
react-scripts
├── webpack (+ 50개 관련 패키지)
├── babel (+ 30개 관련 패키지)
├── eslint (+ 40개 관련 패키지)
├── jest (+ 60개 관련 패키지)
├── postcss (+ 20개 관련 패키지)
└── ... (계속해서 수백 개)
```

**문제점들:**
- 보안 취약점이 있는 패키지를 직접 업데이트할 수 없음
- 특정 버전의 도구만 사용 가능 (예: 오래된 Webpack)
- 충돌하는 의존성 해결 불가능
- 번들 크기와 설치 시간 급증

### 업데이트의 악몽

CRA의 업데이트는 정말 고통스럽다. Major 버전이 올라갈 때마다 Breaking Change의 향연이 시작된다.

**CRA 3 → 4 업데이트 때:**
- Node.js 버전 요구사항 변경
- Jest 설정 변경으로 기존 테스트 깨짐
- Webpack 설정 변경으로 일부 라이브러리 호환성 문제
- CSS 처리 방식 변경으로 스타일 깨짐

**CRA 4 → 5 업데이트 때:**
- Webpack 5로 업그레이드로 Polyfill 자동 제공 중단
- Fast Refresh 도입으로 HMR 방식 변경
- 일부 PostCSS 플러그인 호환성 문제

프로젝트가 복잡할수록 업데이트는 더 어려워진다. 결국 많은 팀들이 "굳이 업데이트 안 해도 되지 않나요?"라며 방치하게 된다.

## 성능 문제: 느린 개발, 무거운 빌드

### 개발 서버의 답답함

CRA의 개발 서버는 프로젝트가 커질수록 느려진다. Webpack Dev Server 기반이라 근본적인 한계가 있다.

**실제 경험한 속도 문제:**
- 초기 서버 시작: 소규모 프로젝트도 30초+
- Hot Reload: 파일 저장 후 반영까지 3-5초
- 페이지 새로고침: 큰 프로젝트에서는 10초+
- 번들 크기 증가에 따른 지속적인 성능 저하

이는 개발 생산성에 직접적인 영향을 미친다. 파일을 수정하고 결과를 보기까지 기다리는 시간이 누적되면 상당한 시간 손실이다.

### 빌드 시간의 현실

프로덕션 빌드도 마찬가지로 느리다. CI/CD 파이프라인에서 빌드 시간이 병목이 되는 경우가 많다.

```bash
# 실제 CRA 프로젝트 빌드 시간 (중간 규모)
npm run build
> Building for production...
> Creating an optimized production build...
> Compiled successfully in 4m 32s
```

4분 30초... 이는 작은 변경사항 하나를 배포하기 위해서도 기다려야 하는 시간이다. 팀 전체의 개발 속도를 떨어뜨리는 요인이다.

### 번들 최적화의 한계

CRA는 번들 최적화 옵션이 제한적이다. 기본 설정으로는 최적화가 부족하고, 커스터마이징하려면 eject를 해야 한다.

**기본 CRA 번들의 문제점:**
- Tree shaking이 완전하지 않음
- Code splitting이 제한적
- 사용하지 않는 polyfill 포함
- CSS 최적화 부족

실제 프로젝트에서 Lighthouse 점수를 개선하려면 결국 CRA를 벗어나야 했다.

## 생태계 변화와 CRA의 고립

### Modern Build Tools의 등장

2020년 이후 프론트엔드 빌드 도구 생태계가 급변했다. Vite, Parcel, Snowpack 등 새로운 도구들이 등장하면서 CRA의 단점이 더욱 부각되었다.

**Vite vs CRA 비교 (실제 프로젝트 기준):**
```
개발 서버 시작 시간:
- CRA: 45초
- Vite: 3초

Hot Reload 속도:
- CRA: 3-5초
- Vite: 0.5초 미만

번들 크기:
- CRA: 2.3MB (gzipped 680KB)
- Vite: 1.8MB (gzipped 520KB)
```

이런 차이를 경험하고 나면 CRA로 돌아가기 어렵다.

### React 18과의 미묘한 갈등

React 18에서 도입된 새로운 기능들(Concurrent Features, Suspense, Server Components 등)을 제대로 활용하려면 더 현대적인 설정이 필요하다.

하지만 CRA는 React 팀의 핵심 관심사가 아니다. React 자체 개발에 집중하느라 CRA 업데이트는 뒷전이 되었다.

**React 18 기능과 CRA의 괴리:**
- Server Components: CRA에서 지원 불가
- Streaming SSR: 별도 설정 필요
- Concurrent Features: 부분적 지원
- 새로운 Hooks: 기본 설정으로 최적화 부족

### TypeScript 지원의 아쉬움

CRA의 TypeScript 지원은 기본적인 수준에 머물러 있다. 실제 TypeScript 프로젝트에서 필요한 고급 기능들이 부족하다.

```typescript
// CRA TypeScript 설정의 한계
{
  "compilerOptions": {
    // 변경할 수 없는 고정 설정들
    "target": "es5", // 최신 문법 사용 불가
    "module": "esnext",
    "strict": true, // 세밀한 조정 불가
    // ...
  }
}
```

**아쉬운 점들:**
- tsconfig.json 커스터마이징 제한
- 경로 매핑(Path Mapping) 설정 복잡
- Decorator 지원 부족
- 타입 체킹 최적화 부족

## 실제 마이그레이션 사례: 탈출의 기록들

### 사례 1: CRA에서 Vite로 이주한 중견기업

한 중견기업의 대시보드 프로젝트가 CRA의 한계에 부딪혔다. 20명의 개발자가 동시에 작업하는데 개발 서버가 너무 느려서 생산성이 떨어졌다.

**마이그레이션 과정:**
1. Vite 설정 파일 작성
2. import 경로 수정 (Vite는 확장자 필수)
3. 환경변수 접두사 변경 (REACT_APP_ → VITE_)
4. 일부 Webpack 전용 라이브러리 교체
5. 빌드 스크립트 수정

**결과:**
- 개발 서버 시작: 60초 → 5초
- Hot Reload: 4초 → 0.5초
- 프로덕션 빌드: 8분 → 2분
- 번들 크기: 15% 감소

하지만 마이그레이션에 2주가 걸렸고, 팀 전체가 새로운 도구에 적응하는 데 추가 시간이 필요했다.

### 사례 2: Next.js로 완전한 전환

한 스타트업은 아예 CRA를 포기하고 Next.js로 전환했다. SSR 요구사항이 추가되면서 CRA로는 한계가 있었다.

**전환 이유:**
- SEO 개선 필요성
- 페이지 로딩 속도 최적화
- 개발 경험 개선
- 미래 확장성 고려

**전환 과정의 어려움:**
- 라우팅 시스템 완전 재작성
- 상태 관리 로직 수정
- CSS-in-JS 라이브러리 교체
- API 호출 패턴 변경

결과적으로는 만족스러웠지만, 3개월이라는 상당한 시간과 비용이 투입되었다.

### 사례 3: Eject 후 커스터마이징 지옥

어떤 팀은 CRA를 eject 해서 커스터마이징했다. 하지만 이는 더 큰 문제의 시작이었다.

**Eject 후 마주친 문제들:**
- 500개 이상의 의존성 직접 관리
- Webpack 설정 복잡성 급증
- 보안 업데이트 수동 적용
- 새로운 팀원의 학습 곡선 급증
- 유지보수 비용 폭증

결국 6개월 후 다른 솔루션으로 다시 마이그레이션하게 되었다.

## 대안들의 현실적 평가

### Vite: 현재의 최선책

Vite는 현재 가장 합리적인 대안이다. 빠른 개발 경험과 유연한 설정을 제공한다.

**장점:**
- 매우 빠른 개발 서버와 HMR
- 플러그인 기반의 유연한 확장성
- TypeScript 네이티브 지원
- Tree shaking과 코드 분할 최적화

**단점:**
- 상대적으로 새로운 도구 (안정성 우려)
- 일부 라이브러리 호환성 문제
- CRA 대비 설정 복잡성 증가
- 커뮤니티 리소스 부족

### Next.js: 풀스택의 유혹

Next.js는 단순한 빌드 도구를 넘어 풀스택 프레임워크다.

**장점:**
- SSR/SSG 기본 지원
- API Routes로 백엔드 기능
- 이미지 최적화, 폰트 최적화 등 내장
- Vercel 연동으로 쉬운 배포

**단점:**
- 과도한 기능 (SPA만 필요한 경우)
- 프레임워크 종속성 증가
- 빌드 시간 여전히 긴 편
- 러닝 커브 존재

### Parcel: 진짜 Zero Configuration

Parcel은 진정한 Zero Configuration을 표방한다.

**장점:**
- 정말 설정 파일 없이 시작 가능
- 자동 의존성 분석과 번들링
- 빠른 빌드 속도

**단점:**
- 커스터마이징 옵션 제한적
- 복잡한 프로젝트에서 예측 불가능한 동작
- 디버깅 어려움
- 생태계 지원 부족

### Webpack 직접 설정: 고수의 길

아예 Webpack을 직접 설정하는 방법도 있다.

**장점:**
- 완전한 제어권
- 프로젝트 요구사항에 최적화 가능
- 최신 기능 즉시 적용 가능

**단점:**
- 매우 높은 학습 곡선
- 초기 설정 시간 상당
- 유지보수 부담 증가
- 팀원 간 지식 격차 발생

## CRA 사후처리: 기존 프로젝트는 어떻게?

### 전략 1: 현상유지 (단기)

당장 큰 문제가 없다면 현상을 유지하는 것도 방법이다.

**언제까지 가능한가:**
- 보안 패치는 계속 제공될 예정
- Node.js LTS 지원은 당분간 유지
- 기존 기능은 그대로 동작

**주의사항:**
- 새로운 React 기능 활용 어려움
- 성능 개선 한계
- 신규 채용시 기술 스택 어필 부족

### 전략 2: 점진적 마이그레이션 (중기)

새로운 기능부터 다른 도구로 개발하고 점진적으로 전환하는 방법이다.

**Micro Frontend 활용:**
```typescript
// 기존 CRA 프로젝트는 유지
// 새로운 기능은 Vite로 개발
const NewFeature = lazy(() => import('new-feature-app/Component'))

function App() {
  return (
    <div>
      <LegacyComponent /> {/* CRA 프로젝트 */}
      <Suspense fallback={<Loading />}>
        <NewFeature /> {/* Vite 프로젝트 */}
      </Suspense>
    </div>
  )
}
```

### 전략 3: 완전 마이그레이션 (장기)

전체 프로젝트를 새로운 도구로 완전히 이전하는 방법이다.

**준비사항:**
- 마이그레이션 대상 도구 선정
- 기존 코드 호환성 검증
- 팀 교육 계획
- 마이그레이션 일정 수립
- 롤백 계획 준비

## 진짜 문제: 생태계의 복잡성

### 선택의 피로

CRA가 사라지면서 개발자들은 "선택의 피로"에 시달리고 있다. 각각의 도구는 장단점이 있고, 완벽한 해답은 없다.

**고려해야 할 요소들:**
- 프로젝트 규모와 복잡성
- 팀의 기술 수준
- 성능 요구사항
- 미래 확장성
- 유지보수 비용
- 커뮤니티 지원

### 학습 비용의 증가

CRA 시절에는 React만 배우면 되었다. 이제는 빌드 도구까지 별도로 학습해야 한다.

**신입 개발자의 러닝 커브:**
- React 기초 학습
- 선택한 빌드 도구 학습
- 설정 파일 이해
- 트러블슈팅 능력
- 생태계 이해

이는 React 진입 장벽을 높이는 요인이 된다.

### 표준화의 부재

CRA가 있을 때는 암묵적인 표준이 있었다. 이제는 팀마다, 회사마다 다른 도구를 사용한다.

**표준화 부재의 문제:**
- 프로젝트 간 이동시 적응 필요
- 오픈소스 프로젝트 설정 다양화
- 튜토리얼과 강의 내용 분산
- 채용시 기술 스택 불일치

## 결론: 변화를 받아들이고 현명하게 대응하기

CRA의 종료는 React 생태계에 큰 변화를 가져올 것이다. 하지만 이는 위기가 아니라 기회다.

**CRA가 우리에게 준 교훈:**
1. **편의성의 대가**: 쉬운 시작에는 숨겨진 복잡성이 있다
2. **종속성의 위험**: 하나의 도구에 과도하게 의존하면 안 된다
3. **변화의 필연성**: 기술은 계속 발전하고 도구도 바뀐다

**앞으로의 전략:**
1. **점진적 학습**: 새로운 도구들을 꾸준히 학습하고 실험해보자
2. **유연한 마인드**: 완벽한 도구는 없다는 것을 인정하자
3. **팀 차원의 접근**: 개인이 아닌 팀 전체의 관점에서 결정하자
4. **지속적 평가**: 선택한 도구가 계속 적합한지 주기적으로 평가하자

**기억해야 할 것:**
CRA는 5년간 수많은 개발자들이 React를 시작할 수 있게 도왔다. 그 기여는 인정하되, 이제는 새로운 방향으로 나아가야 할 때다.

변화를 두려워하지 말자. CRA의 종료는 React 생태계가 더욱 성숙해지고 있다는 증거다. 더 나은 도구들과 함께 더 나은 개발 경험을 만들어가자.

**마지막으로**, 도구는 수단일 뿐이다. 중요한 것은 좋은 사용자 경험을 제공하는 것이다. 어떤 도구를 선택하든 그 목적을 잊지 말자. 