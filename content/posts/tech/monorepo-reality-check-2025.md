---
title: "Monorepo, 정말 은탄환일까? 화려한 성공담 뒤에 숨겨진 실패의 기록들"
date: "2025-04-25"
category: "tech"
tags: ["Monorepo", "Architecture", "DevOps", "TeamManagement", "Reality"]
excerpt: "Google과 Meta가 한다고 우리도 해야 할까? 4년간 다양한 규모의 Monorepo를 운영해본 현실적 경험담. 화려한 성공 사례 뒤에 숨겨진 복잡성과 실패 비용을 낱낱이 파헤친다."
author: "KISO"
image: "https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop"
---

# Monorepo, 정말 은탄환일까? 화려한 성공담 뒤에 숨겨진 실패의 기록들

"Google도 쓰고, Meta도 쓰는 Monorepo! 우리도 도입해야 합니다!"

개발팀 회의에서 한 번쯤 들어봤을 법한 이야기다. Monorepo는 마치 모든 개발 문제를 해결해줄 만능 해결책처럼 포장되어 있다. 코드 공유도 쉽고, 의존성 관리도 간단하고, 배포도 일관성 있게 할 수 있다고 한다.

하지만 정말 그럴까? 4년간 스타트업부터 중견기업까지 다양한 환경에서 Monorepo를 도입하고 운영해본 결과, 한 가지 확실한 사실을 깨달았다. **Monorepo는 은탄환이 아니다.** 오히려 새로운 복잡성과 예상치 못한 비용을 가져다주는 경우가 더 많았다.

## 성공 사례에 가려진 전제 조건들

### Google의 Monorepo ≠ 당신의 Monorepo

Google이 Monorepo를 성공적으로 운영한다는 이야기는 유명하다. 하지만 사람들이 놓치는 중요한 사실이 있다. Google의 Monorepo가 성공할 수 있는 이유는 **Google이기 때문이다.**

Google은 Monorepo를 위해 Bazel, Piper, CitC(Clients in the Cloud) 같은 전용 도구들을 수년에 걸쳐 개발했다. 수백 명의 엔지니어가 인프라 개발에만 매달렸고, 수천만 달러를 투자했다. 이런 투자 없이 Google의 성공을 따라 할 수 있다고 생각하는 것 자체가 착각이다.

더 중요한 것은 조직 문화다. Google의 엔지니어들은 엄격한 코드 리뷰 문화와 높은 기술적 역량을 갖추고 있다. 새로운 도구나 프로세스를 학습하고 적응하는 능력도 뛰어나다. 이런 조건 없이 Monorepo를 도입하면 재앙이 될 수 있다.

### Meta의 사례가 말해주지 않는 것들

Meta(Facebook) 역시 Monorepo 성공 사례로 자주 언급된다. 하지만 Meta가 공개하지 않는 이면의 이야기들이 있다.

Meta의 Monorepo 전환 과정에서 수개월간 개발 생산성이 크게 떨어졌다. 기존 워크플로우에 익숙했던 개발자들이 새로운 시스템에 적응하는데 오랜 시간이 걸렸다. CI/CD 시스템을 완전히 재구축해야 했고, 이 과정에서 수많은 장애와 배포 실패가 발생했다.

또한 Meta는 Monorepo 도입과 함께 팀 구조와 프로세스를 전면적으로 재편했다. 단순히 코드 저장소만 바꾼 것이 아니라 조직 전체의 일하는 방식을 바꾼 것이다. 이런 배경 없이 "Meta처럼 Monorepo를 쓰면 된다"고 생각하는 것은 위험하다.

## 실제 도입 과정에서 마주치는 현실

### 마이그레이션의 악몽

기존 멀티레포에서 Monorepo로 전환하는 과정은 상상보다 훨씬 복잡하다. 특히 히스토리 보존이 문제다.

각 레포지토리의 git history를 통합하면서 커밋 해시가 모두 바뀐다. 기존에 이슈나 PR에서 참조하던 커밋들이 모두 깨진다. blame 정보도 엉망이 된다. "이 코드를 누가 언제 왜 작성했는지" 추적하기 어려워진다.

한 스타트업에서는 5개의 레포지토리를 통합하는 과정에서 3개월을 소모했다. 단순히 코드를 옮기는 것이 아니라, CI/CD 파이프라인을 재구축하고, 배포 스크립트를 수정하고, 환경 변수를 정리하는 등 예상치 못한 작업들이 계속 생겨났다.

### CI/CD의 복잡성 폭증

Monorepo의 가장 큰 문제 중 하나는 CI/CD다. 이론적으로는 "변경된 부분만 빌드하면 된다"고 하지만, 실제로는 그렇게 간단하지 않다.

의존성 그래프를 정확히 파악하기 어렵다. A 패키지를 수정했을 때 B와 C 패키지에 영향을 주는지 알기 위해서는 복잡한 분석이 필요하다. 이를 위해 Nx, Rush, Lerna 같은 도구들을 사용하지만, 이 도구들 자체가 또 다른 복잡성을 가져온다.

더 심각한 것은 CI 시간이다. 하나의 작은 변경사항이라도 전체 테스트 스위트를 돌려야 하는 경우가 많다. 의존성 분석이 잘못되면 불필요한 빌드가 실행되고, 반대로 놓치면 버그가 프로덕션에 배포된다.

## 팀 협업에서 발생하는 문제들

### 코드 소유권의 모호함

Monorepo에서는 모든 코드가 한 곳에 있다. 이는 코드 공유에는 좋지만, 소유권과 책임 관계를 모호하게 만든다.

어떤 팀이 어떤 코드를 책임져야 하는지 불분명해진다. 공통 라이브러리를 수정할 때 누구에게 리뷰를 받아야 하는지, 문제가 생겼을 때 누가 고쳐야 하는지 애매하다. 결국 "아무도 책임지지 않는 코드"가 늘어난다.

한 회사에서는 공통 컴포넌트 라이브러리에 버그가 있었는데, 6개월 동안 아무도 고치지 않았다. 각 팀은 "다른 팀이 만든 거니까 우리가 고칠 필요 없다"고 생각했고, 원래 만든 팀은 이미 다른 프로젝트로 넘어간 상태였다.

### 코드 리뷰의 부담 증가

Monorepo에서는 하나의 PR이 여러 패키지에 영향을 줄 수 있다. 이는 코드 리뷰를 복잡하게 만든다.

리뷰어는 자신이 잘 모르는 영역의 코드까지 검토해야 할 수 있다. 반대로 리뷰 요청을 받는 사람이 너무 많아져서 리뷰 속도가 느려진다. "모든 변경사항을 모든 사람이 봐야 한다"는 원칙은 이상적이지만 현실적으로 불가능하다.

결국 형식적인 리뷰가 늘어난다. 제대로 검토하지 않고 LGTM만 남기는 경우가 많아진다. 이는 코드 품질 저하로 이어진다.

## 기술적 부채의 집중화

### 의존성 지옥의 새로운 형태

Monorepo는 의존성 관리를 단순화한다고 약속하지만, 실제로는 새로운 형태의 의존성 지옥을 만든다.

하나의 라이브러리를 업데이트하려면 그것에 의존하는 모든 패키지를 확인해야 한다. breaking change가 있으면 수십 개의 패키지를 동시에 수정해야 할 수도 있다. 이는 작은 업데이트도 거대한 작업으로 만든다.

특히 외부 라이브러리 업데이트가 문제다. 보안 패치를 적용하려고 했는데, 하나의 패키지에서 호환성 문제가 발생하면 전체 Monorepo의 업데이트가 막힌다.

### 레거시 코드의 피할 수 없는 확산

Monorepo에서는 레거시 코드를 피하기 어렵다. 모든 코드가 한 곳에 있기 때문에, 오래된 코드와 새로운 코드가 뒤섞인다.

새로운 기능을 개발할 때도 기존 코드의 영향을 고려해야 한다. "깨끗하게 새로 시작하자"고 해도 기존 코드와의 호환성 때문에 타협해야 하는 경우가 많다.

## 도구와 인프라의 숨겨진 비용

### 전용 도구의 학습 곡선

Monorepo를 제대로 운영하려면 전용 도구들을 배워야 한다. Nx, Rush, Lerna, Bazel 등 각각 고유한 설정과 명령어를 가지고 있다.

이 도구들은 각자의 철학과 방식이 있어서, 하나를 배웠다고 다른 것을 쉽게 쓸 수 있는 것도 아니다. 팀 전체가 새로운 도구를 학습해야 하고, 이는 상당한 시간과 비용을 요구한다.

더 문제는 이 도구들이 계속 진화한다는 점이다. 새로운 버전이 나올 때마다 breaking change가 있고, 기존 설정을 수정해야 한다. 도구 자체가 기술 부채가 된다.

### 인프라 복잡성의 증가

Monorepo는 빌드와 배포 인프라에 큰 부담을 준다. 일반적인 CI 시스템으로는 효율적으로 처리하기 어렵다.

전용 빌드 캐시 시스템이 필요하고, 분산 빌드 환경을 구축해야 할 수도 있다. 이는 인프라 비용과 관리 복잡성을 크게 증가시킨다.

한 회사에서는 Monorepo 도입 후 CI 비용이 3배 증가했다. 빌드 시간을 줄이기 위해 더 많은 CI 워커를 돌려야 했고, 캐시 스토리지 비용도 추가로 발생했다.

## 실패 사례들: 현실의 경고

### 사례 1: 스타트업 C의 2년 간의 삽질

스타트업 C는 빠른 개발을 위해 Monorepo를 도입했다. 초기에는 괜찮았다. 프론트엔드와 백엔드가 같은 타입을 공유할 수 있었고, 공통 유틸리티를 쉽게 사용할 수 있었다.

문제는 팀이 커지면서 시작됐다. 10명이 넘어가자 merge conflict가 일상이 되었다. 각자 다른 기능을 개발하는데도 package.json이나 공통 설정 파일에서 충돌이 계속 발생했다.

더 심각한 것은 배포였다. 프론트엔드만 수정했는데 백엔드도 함께 배포되는 일이 빈번했다. 배포 파이프라인을 분리하려고 했지만, 공통 의존성 때문에 완전히 분리하기 어려웠다.

결국 2년 후, 다시 멀티레포로 돌아섰다. 마이그레이션 과정에서 3개월을 소모했고, 그동안 새로운 기능 개발은 거의 중단되었다.

### 사례 2: 중견기업 D의 성능 재앙

중견기업 D는 15개의 마이크로서비스를 하나의 Monorepo로 통합했다. 목표는 코드 재사용성 향상과 일관성 있는 개발 환경 구축이었다.

초기에는 공통 라이브러리를 쉽게 공유할 수 있어서 만족도가 높았다. 하지만 6개월 후부터 문제가 시작됐다.

CI 시간이 기하급수적으로 늘어났다. 작은 변경사항이라도 전체 테스트를 돌리는데 1시간 이상 걸렸다. 개발자들의 생산성이 크게 떨어졌다.

더 심각한 것은 장애 전파였다. 하나의 서비스에 문제가 생기면 배포 파이프라인 전체가 막혔다. 긴급 패치를 적용하려고 해도 다른 서비스의 실패한 테스트 때문에 배포할 수 없는 상황이 반복됐다.

결국 "Monorepo를 유지하되 빌드/배포는 분리하자"는 절충안을 택했지만, 이는 Monorepo의 장점을 대부분 포기하는 것이었다.

## 숨겨진 인적 비용

### 전문가 의존성

Monorepo를 제대로 운영하려면 전문가가 필요하다. 빌드 시스템, 의존성 관리, CI/CD 최적화 등 모든 영역에서 깊은 지식이 필요하다.

문제는 이런 전문가가 부족하다는 점이다. 그리고 전문가 한 명에게 의존하게 되면, 그 사람이 없을 때 아무것도 할 수 없는 상황이 된다.

한 회사에서는 Monorepo 전문가가 퇴사한 후 6개월 동안 빌드 시스템을 제대로 건드리지 못했다. 문제가 생겨도 임시방편으로만 해결했고, 기술 부채가 계속 쌓였다.

### 학습 비용의 과소평가

Monorepo는 단순히 코드를 한 곳에 모아놓는 것이 아니다. 새로운 패러다임이고, 새로운 방식으로 생각해야 한다.

기존에 멀티레포에 익숙한 개발자들이 적응하는데 시간이 걸린다. 특히 시니어 개발자일수록 기존 방식에 익숙해서 더 어려워한다.

이 학습 비용은 프로젝트 계획에 거의 반영되지 않는다. "그냥 도구만 바뀌는 거 아닌가요?"라고 생각하지만, 실제로는 개발 프로세스 전체가 바뀐다.

## 언제 Monorepo를 피해야 할까?

### 팀 규모와 성숙도

팀이 작거나 기술적 성숙도가 낮다면 Monorepo는 권하지 않는다. 특히 다음과 같은 경우는 위험하다:

- **5명 이하의 소규모 팀**: 오버엔지니어링의 전형
- **DevOps 전문가가 없는 팀**: 인프라 관리가 부담이 됨
- **코드 리뷰 문화가 정착되지 않은 팀**: 품질 관리가 더 어려워짐
- **레거시 시스템이 많은 조직**: 기술 부채가 집중될 위험

### 프로젝트 특성

모든 프로젝트가 Monorepo에 적합한 것은 아니다:

- **독립적인 서비스들**: 억지로 묶을 필요 없음
- **다른 기술 스택**: 무리한 통합은 복잡성만 증가
- **다른 배포 주기**: 함께 배포할 이유가 없다면 분리가 나음
- **다른 팀의 소유**: 조직 경계를 넘나드는 Monorepo는 관리가 어려움

## 대안은 없을까?

### 멀티레포 + 공통 도구

Monorepo 없이도 코드 공유와 일관성을 달성할 수 있다:

- **공통 라이브러리의 패키지화**: npm/pip 등으로 배포
- **공통 템플릿과 스캐폴딩**: yeoman, create-react-app 스타일
- **통합된 CI/CD 파이프라인**: Jenkins 공유, GitHub Actions 템플릿
- **코드 표준화 도구**: ESLint, Prettier 설정 공유

### Polyrepo 전략

각 서비스를 독립적으로 관리하되 필요한 부분만 통합:

- **마이크로 패키지**: 작은 단위로 기능을 패키지화
- **계약 기반 개발**: API 스펙을 먼저 정의하고 개발
- **통합 테스트 환경**: 별도의 통합 테스트 저장소
- **공통 인프라**: Docker, Kubernetes 등으로 배포 환경 통일

## 결론: 냉정한 판단이 필요한 시점

Monorepo는 만능 해결책이 아니다. Google이나 Meta의 성공 사례를 보고 "우리도 해야 한다"고 성급하게 결정하면 안 된다.

**Monorepo가 정말 필요한 경우:**
- 강하게 결합된 여러 패키지가 있고
- 숙련된 DevOps 팀이 있으며
- 코드 품질 관리 프로세스가 잘 정착되어 있고
- 장기적인 투자를 할 준비가 되어 있을 때

**그 외의 경우라면:**
멀티레포로 시작해서 정말 필요할 때만 Monorepo로 전환하는 것이 현명하다. 조급하게 도입했다가 나중에 다시 분리하는 비용이 훨씬 크다.

가장 중요한 것은 **본질을 놓치지 않는 것**이다. 코드 구조보다 중요한 것은 팀 문화, 프로세스, 그리고 비즈니스 요구사항이다. 도구에 팀을 맞추려 하지 말고, 팀에 맞는 도구를 선택해야 한다.

Monorepo는 하나의 선택지일 뿐이다. 은탄환이 아니라는 점을 명심하자. 그래야 실패 비용을 줄이고 진짜 문제에 집중할 수 있다. 